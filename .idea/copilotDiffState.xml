<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/nnformer/utilities/derive_pool_sizes.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/nnformer/utilities/derive_pool_sizes.py" />
              <option name="updatedContent" value="import argparse&#10;import ast&#10;from typing import List, Sequence&#10;&#10;&#10;def parse_list(s: str):&#10;    try:&#10;        return ast.literal_eval(s)&#10;    except Exception as e:&#10;        raise argparse.ArgumentTypeError(f&quot;Cannot parse list from: {s}. Error: {e}&quot;)&#10;&#10;&#10;def elemwise_ratio(a: Sequence[int], b: Sequence[int]) -&gt; List[int]:&#10;    if len(a) != len(b):&#10;        raise ValueError(f&quot;Mismatched lengths in elementwise ratio: {len(a)} vs {len(b)}&quot;)&#10;    out = []&#10;    for ai, bi in zip(a, b):&#10;        if bi == 0:&#10;            raise ValueError(&quot;Division by zero in stride ratio&quot;)&#10;        if ai % bi != 0:&#10;            # allow non-integer ratio? In nnU-Net we need integer kernel sizes.&#10;            raise ValueError(f&quot;Stride is not divisible per-axis: next={a} prev={b}&quot;)&#10;        out.append(ai // bi)&#10;    return out&#10;&#10;&#10;def derive_pool_op_kernel_sizes(&#10;    down_stride: List[Sequence[int]],&#10;    embedding_patch_size: Sequence[int] = None,&#10;    depths: Sequence[int] = None,&#10;    num_heads: Sequence[int] = None,&#10;    window_size: List[Sequence[int]] = None,&#10;):&#10;    stages = len(down_stride)&#10;    if stages &lt; 1:&#10;        raise ValueError(&quot;down_stride must have at least one stage&quot;)&#10;&#10;    # Sanity: down_stride must be cumulative and strictly increasing or equal per axis&#10;    for i in range(1, stages):&#10;        prev, curr = down_stride[i - 1], down_stride[i]&#10;        if len(prev) != len(curr):&#10;            raise ValueError(f&quot;down_stride dims mismatch at stage {i-1}-&gt;{i}: {prev} vs {curr}&quot;)&#10;        for d, (p, c) in enumerate(zip(prev, curr)):&#10;            if c % p != 0:&#10;                raise ValueError(&#10;                    f&quot;down_stride must be cumulative. Axis {d} stage {i}: {c} is not a multiple of previous {p}&quot;&#10;                )&#10;&#10;    if embedding_patch_size is not None:&#10;        if len(embedding_patch_size) != len(down_stride[0]):&#10;            raise ValueError(&#10;                f&quot;embedding_patch_size dims {embedding_patch_size} must match down_stride[0] dims {down_stride[0]}&quot;&#10;            )&#10;        # In this codebase, Encoder.input_resolution uses pretrain_img_size // down_stride[i].&#10;        # So the first stage stride equals the patch embedding stride along each axis.&#10;        if list(embedding_patch_size) != list(down_stride[0]):&#10;            raise ValueError(&#10;                f&quot;Expected down_stride[0] == embedding_patch_size. Got {down_stride[0]} vs {embedding_patch_size}&quot;&#10;            )&#10;&#10;    if depths is not None and len(depths) != stages:&#10;        raise ValueError(&#10;            f&quot;depths length ({len(depths)}) must equal len(down_stride) ({stages}) (one per stage).&quot;&#10;        )&#10;    if num_heads is not None and len(num_heads) != stages:&#10;        raise ValueError(&#10;            f&quot;num_heads length ({len(num_heads)}) must equal len(down_stride) ({stages}) (one per stage).&quot;&#10;        )&#10;&#10;    # pool_op_kernel_sizes are per transition between stages (stages-1 entries)&#10;    pool = []&#10;    for i in range(stages - 1):&#10;        prev = down_stride[i]&#10;        nxt = down_stride[i + 1]&#10;        pool.append(elemwise_ratio(nxt, prev))&#10;&#10;    # Optional checks with window sizes: input_resolution = crop_size // down_stride[i].&#10;    # The model pads to multiples of window_size so we just warn instead of failing.&#10;    if window_size is not None:&#10;        if len(window_size) != stages:&#10;            print(&#10;                f&quot;[warn] window_size length ({len(window_size)}) != stages ({stages}). Skipping window checks.&quot;&#10;            )&#10;        # else: cannot validate without crop_size; user can check separately.&#10;&#10;    return pool&#10;&#10;&#10;def main():&#10;    ap = argparse.ArgumentParser(&#10;        description=(&#10;            &quot;Derive nnU-Net style pool_op_kernel_sizes from nnFormer params: &quot;&#10;            &quot;down_stride, embedding_patch_size, depths, num_heads, window_size.&quot;&#10;        )&#10;    )&#10;    ap.add_argument(&quot;--down-stride&quot;, type=parse_list, required=True,&#10;                    help=&quot;JSON/Python list of per-stage cumulative strides, e.g. [[1,4,4],[1,8,8],[2,16,16],[4,32,32]]&quot;)&#10;    ap.add_argument(&quot;--embedding-patch-size&quot;, type=parse_list, required=False,&#10;                    help=&quot;JSON/Python list like [1,4,4]; should equal down_stride[0]&quot;)&#10;    ap.add_argument(&quot;--depths&quot;, type=parse_list, required=False,&#10;                    help=&quot;Per-stage depths (unused except for length check)&quot;)&#10;    ap.add_argument(&quot;--num-heads&quot;, type=parse_list, required=False,&#10;                    help=&quot;Per-stage num_heads (unused except for length check)&quot;)&#10;    ap.add_argument(&quot;--window-size&quot;, type=parse_list, required=False,&#10;                    help=&quot;Per-stage window sizes (unused, only for optional checks)&quot;)&#10;&#10;    args = ap.parse_args()&#10;&#10;    pool = derive_pool_op_kernel_sizes(&#10;        down_stride=args.down_stride,&#10;        embedding_patch_size=args.embedding_patch_size,&#10;        depths=args.depths,&#10;        num_heads=args.num_heads,&#10;        window_size=args.window_size,&#10;    )&#10;    print(pool)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>